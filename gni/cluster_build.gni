# Copyright 2026 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/v8_target_cpu.gni")
import("v8.gni")

# Number of source files per cluster.
cluster_size = 10

# Generates cluster files for a list of .cc files at build time.
#
# Arguments:
#   sources: List of .cc files to cluster
#   prefix: Prefix for cluster file names (e.g., "torque-csa")
#   output_dir: Directory to write cluster files to
#   deps: Dependencies (optional)
#
# In cluster mode: creates an action to generate cluster files
# In non-cluster mode: creates a no-op group
template("cluster_action") {
  assert(defined(invoker.sources), "sources must be defined")
  assert(defined(invoker.prefix), "prefix must be defined")
  assert(defined(invoker.output_dir), "output_dir must be defined")

  _sources = invoker.sources
  _prefix = invoker.prefix
  _output_dir = invoker.output_dir

  # Count source files
  _num_sources = 0
  foreach(s, _sources) {
    _num_sources += 1
  }

  # Compute cluster file names using exec_script
  _cluster_filenames =
      exec_script("//tools/compute_cluster_filenames.py",
                  [
                        "$cluster_size",
                        _prefix,
                      ] + rebase_path(_sources, root_build_dir),
                  "list lines")

  # Add directory prefix to get full paths
  _cluster_outputs = []
  foreach(f, _cluster_filenames) {
    _cluster_outputs += [ "$_output_dir/$f" ]
  }

  if (v8_enable_cluster_build) {
    # Compute the strip prefix - this is the path to the output directory
    # relative to the build directory, used to convert source file paths
    # to paths relative to the cluster file location.
    _strip_prefix = rebase_path(_output_dir, root_build_dir) + "/"

    action(target_name) {
      script = "//tools/generate_cluster_files.py"

      outputs = _cluster_outputs

      args = [
        "--output-dir",
        rebase_path(_output_dir, root_build_dir),
        "--prefix",
        _prefix,
        "--cluster-size",
        "$cluster_size",
        "--strip-prefix",
        _strip_prefix,
      ]
      args += rebase_path(_sources, root_build_dir)

      forward_variables_from(invoker,
                             [
                               "deps",
                               "public_deps",
                               "visibility",
                             ])
    }
  } else {
    # In non-cluster mode, create a group that just passes through deps
    group(target_name) {
      forward_variables_from(invoker,
                             [
                               "deps",
                               "public_deps",
                               "visibility",
                             ])
    }
  }
}

# A v8_source_set that clusters .cc files in cluster mode.
#
# In cluster mode: generates cluster files for .cc sources and compiles those
# In non-cluster mode: compiles sources directly (like v8_source_set)
#
# This template:
# - Groups files by directory (files in same dir are clustered together)
# - Skips arch-specific directories (x64, arm64, etc.)
# - Arch-specific files are compiled individually
#
# Arguments: Same as v8_source_set, plus:
#   cluster_prefix: Optional prefix for cluster file names (defaults to target_name)
#   exclude_from_cluster: Optional list of .cc files to exclude from clustering
#                         (they will be compiled individually)
template("v8_cluster_source_set") {
  _target_name = target_name

  if (v8_enable_cluster_build) {
    # Build a set of excluded files for fast lookup
    _excluded_files = []
    if (defined(invoker.exclude_from_cluster)) {
      _excluded_files = invoker.exclude_from_cluster
    }

    # Extract .cc files from sources for clustering
    _cc_sources = []
    _excluded_cc_sources = []
    _other_sources = []
    if (defined(invoker.sources)) {
      foreach(s, invoker.sources) {
        _ext = get_path_info(s, "extension")
        if (_ext == "cc") {
          # Check if this file is excluded
          _is_excluded = false
          foreach(_excl, _excluded_files) {
            if (s == _excl) {
              _is_excluded = true
            }
          }
          if (_is_excluded) {
            _excluded_cc_sources += [ s ]
          } else {
            _cc_sources += [ s ]
          }
        } else {
          _other_sources += [ s ]
        }
      }
    }

    # Only cluster if we have .cc files
    _num_cc = 0
    foreach(s, _cc_sources) {
      _num_cc += 1
    }

    if (_num_cc > 0) {
      _cluster_prefix = _target_name
      if (defined(invoker.cluster_prefix)) {
        _cluster_prefix = invoker.cluster_prefix
      }

      _output_dir = "$target_gen_dir/clustered"

      # Compute cluster file names with directory grouping and arch skipping
      _cluster_filenames =
          exec_script("//tools/compute_cluster_filenames.py",
                      [
                            "$cluster_size",
                            _cluster_prefix,
                            "--group-by-dir",
                            "--skip-arch-dirs",
                          ] + rebase_path(_cc_sources, root_build_dir),
                      "list lines")

      _cluster_files = []
      foreach(f, _cluster_filenames) {
        _cluster_files += [ "$_output_dir/$f" ]
      }

      # Action to generate cluster files
      action("${_target_name}_generate_clusters") {
        visibility = [ ":*" ]
        script = "//tools/generate_cluster_files.py"

        outputs = _cluster_files

        # Compute the include prefix: from gen/clustered back to build dir
        # The source paths are rebased to build dir, so we need to prepend
        # the path from output_dir back to build dir
        _include_prefix = rebase_path(root_build_dir, _output_dir) + "/"

        args = [
          "--output-dir",
          rebase_path(_output_dir, root_build_dir),
          "--prefix",
          _cluster_prefix,
          "--cluster-size",
          "$cluster_size",
          "--include-prefix",
          _include_prefix,
          "--group-by-dir",
          "--skip-arch-dirs",
        ]
        args += rebase_path(_cc_sources, root_build_dir)

        forward_variables_from(invoker,
                               [
                                 "deps",
                                 "testonly",
                               ])
      }

      # The actual source set with cluster files plus arch-specific files
      v8_source_set(_target_name) {
        forward_variables_from(invoker,
                               "*",
                               [
                                 "sources",
                                 "cluster_prefix",
                                 "exclude_from_cluster",
                               ])

        # Start with non-.cc files, cluster files, and excluded files
        sources = _other_sources + _cluster_files + _excluded_cc_sources

        # Add back arch-specific .cc files (they're compiled individually)
        foreach(s, _cc_sources) {
          _path = rebase_path(s, root_build_dir)

          # Check if path contains arch-specific directory
          _is_arch = false
          foreach(_arch,
                  [
                    "/x64/",
                    "/arm64/",
                    "/arm/",
                    "/ia32/",
                    "/mips64/",
                    "/mips64el/",
                    "/riscv64/",
                    "/riscv32/",
                    "/loong64/",
                    "/ppc64/",
                    "/s390x/",
                    "/s390/",
                  ]) {
            if (string_replace(_path, _arch, "") != _path) {
              _is_arch = true
            }
          }
          if (_is_arch) {
            sources += [ s ]
          }
        }

        if (!defined(deps)) {
          deps = []
        }
        deps += [ ":${_target_name}_generate_clusters" ]
      }
    } else {
      # No .cc files to cluster, just pass through
      v8_source_set(_target_name) {
        forward_variables_from(invoker,
                               "*",
                               [
                                 "cluster_prefix",
                                 "exclude_from_cluster",
                               ])
      }
    }
  } else {
    # Non-cluster mode: just use v8_source_set directly
    v8_source_set(_target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "cluster_prefix",
                               "exclude_from_cluster",
                             ])
    }
  }
}
